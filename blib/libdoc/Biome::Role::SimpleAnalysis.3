.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Biome::Role::SimpleAnalysis 3"
.TH Biome::Role::SimpleAnalysis 3 "2009-08-22" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.Sh "analysis_name"
.IX Subsection "analysis_name"
.Vb 3
\& Usage   : $tool\->analysis_name;
\& Returns : a name of this analysis
\& Args    : none
.Ve
.Sh "analysis_spec"
.IX Subsection "analysis_spec"
.Vb 3
\& Usage   : $tool\->analysis_spec;
\& Returns : a hash reference describing this analysis
\& Args    : none
.Ve
.PP
The returned hash reference uses the following keys (not all of them always
present, perhaps others present as well): \f(CW\*(C`name\*(C'\fR, \f(CW\*(C`type\*(C'\fR, \f(CW\*(C`version\*(C'\fR,
\&\f(CW\*(C`supplier\*(C'\fR, \f(CW\*(C`installation\*(C'\fR, \f(CW\*(C`description\*(C'\fR.
.Sh "input_spec"
.IX Subsection "input_spec"
.Vb 3
\& Usage   : $tool\->input_spec;
\& Returns : an array reference with hashes as elements
\& Args    : none
.Ve
.PP
The analysis input data are named, and can be also associated with a
default value, with allowed values and with few other attributes. The
names are important for feeding the analysis with the input data (the
inputs are given to methods \f(CW\*(C`run\*(C'\fR and \f(CW\*(C`wait_for\*(C'\fR as name/value
pairs).
.Sh "result_spec"
.IX Subsection "result_spec"
.Vb 4
\& Usage   : $tool\->result_spec;
\& Returns : a hash reference with result names as keys
\&           and result types as values
\& Args    : none
.Ve
.PP
An analysis can produce several results, or the same result in several
different formats. All such results are named and can be retrieved
using their names by metod \f(CW\*(C`result\*(C'\fR.
.PP
Here is an example of the result specification:
.PP
.Vb 5
\&  $result_spec = {
\&          \*(Aqoutseq\*(Aq => \*(AqString\*(Aq,
\&          \*(Aqreport\*(Aq => \*(AqString\*(Aq,
\&          \*(Aqdetailed_status\*(Aq => \*(AqString\*(Aq
\&        };
.Ve
.Sh "run"
.IX Subsection "run"
.Vb 4
\& Usage   : $tool\->run ( [\*(Aqsequence=@my.seq\*(Aq, \*(Aqosformat=embl\*(Aq] )
\& Returns : $self
\& Args    : data and parameters for this execution
\&           (in various formats)
.Ve
.PP
Create a job, start it, and wait for its completion. The method is
identical to the method \f(CW\*(C`wait_for\*(C'\fR. Why there are two methods doing
the same? Because it is expected that the sub-classes may implement
them differently (an example is an interface \f(CW\*(C`Bio::AnalysisI\*(C'\fR which
uses method \f(CW\*(C`run\*(C'\fR for an asynchronous execution and method
\&\f(CW\*(C`wait_for\*(C'\fR for a synchronous one.
.PP
Usually, after this call, you ask for results of the finished job:
.PP
.Vb 1
\&    $analysis\->run (...)\->result;
.Ve
.PP
The input data and prameters for this execution can be specified in
various ways:
.IP "array reference" 4
.IX Item "array reference"
The array has scalar elements of the form
.Sp
.Vb 1
\&   name = [[@]value]
.Ve
.Sp
where \f(CW\*(C`name\*(C'\fR is the name of an input data or input parameter (see
method \f(CW\*(C`input_spec\*(C'\fR for finding what names are recognized by this
analysis) and \f(CW\*(C`value\*(C'\fR is a value for this data/parameter. If \f(CW\*(C`value\*(C'\fR
is missing a 1 is assumed (which is convenient for the boolean
options). If \f(CW\*(C`value\*(C'\fR starts with \f(CW\*(C`@\*(C'\fR it is treated as a local
filename, and its contents is used as the data/parameter value.
.IP "hash reference" 4
.IX Item "hash reference"
The same as with the array reference but now there is no need to use
an equal sign. The hash keys are input names and hash values their
data. The values can again start with a \f(CW\*(C`@\*(C'\fR sign indicating a local
filename.
.Sh "wait_for"
.IX Subsection "wait_for"
.Vb 3
\& Usage   : $tool\->wait_for ( { \*(Aqsequence\*(Aq => \*(Aq@my,file\*(Aq } )
\& Returns : $self
\& Args    : the same as for method \*(Aqrun\*(Aq
.Ve
.PP
Create a job, start it and wait for its completion. The method is
identical to the method \f(CW\*(C`run\*(C'\fR. See details in the \f(CW\*(C`run\*(C'\fR method.
.Sh "status"
.IX Subsection "status"
.Vb 3
\& Usage   : $tool\->status
\& Returns : string describing a status of the execution
\& Args    : none
.Ve
.PP
It returns one of the following strings (and perhaps more if a server
implementation extended possible job states):
.PP
.Vb 3
\&   CREATED              (not run yet)
\&   COMPLETED            (run and finished normally)
\&   TERMINATED_BY_ERROR  (run and finished with an error or a signal)
.Ve
.Sh "result"
.IX Subsection "result"
.Vb 5
\& Usage   : $job\->result (...)
\& Returns : a result created by running an analysis
\& Args    : none (but an implementation may choose
\&           to add arguments for instructions how to process
\&           the raw result)
.Ve
.PP
The method returns a scalar representing a result of an executed
job. If the job was terminated by an error the result may contain an
error message instead of the real data (or both, depending on the
implementation).
