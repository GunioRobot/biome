.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Biome::Role::CollectAnnotation 3"
.TH Biome::Role::CollectAnnotation 3 "2009-08-22" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Biome::Role::CollectAnnotation \- Role for collecting Annotation (or any
Biome::Role::Annotate consumers)
.SH "VERSION"
.IX Header "VERSION"
This documentation refers to Biome::Role::CollectAnnotation version 0.01.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MyAnnotationCollection;
\&    
\&    use Biome;
\&    
\&    with qw(Biome::Role::CollectAnnotation
\&            Biome::Role::ManageTypes);  # class consumes both roles
\&
\&    # .....
\&    
\&    package main;
\&
\&    use MyAnnotation;
\&    use MyAnnotationCollection;
\&    
\&    # Biome::Role::Annotate consumer
\&    my $ann = MyAnnotation\->new(\-tagname => \*(Aqfoo\*(Aq, \-bar => \*(Aqbaz\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Describes the basic abstract interface role for collecting any
Biome::Annotation::* or other Biome::Role::Annotate consumers. Consumers of this
role.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.Sh "Greedy methods"
.IX Subsection "Greedy methods"
.Sh "\fIget_Annotation_keys()\fP"
.IX Subsection "get_Annotation_keys()"
.Vb 8
\& Title    : get_Annotation_keys
\& Usage    : $ac\->get_all_annotation_keys()
\& Function : Gives back a list of Annotation keys, which are simple text strings.
\&            This returns only the keys at the first level in the hierarchy (ones
\&            immediately available)
\& Returns  : Array of strings
\& Args     : none 
\& Status   : Virtual
.Ve
.Sh "\fIget_all_Annotation_keys()\fP"
.IX Subsection "get_all_Annotation_keys()"
.Vb 8
\& Title    : get_all_Annotation_keys
\& Usage    : $ac\->get_all_Annotation_keys()
\& Function : gives back a list of Annotation keys, which are simple text strings.
\&            This returns all keys in this Collection
\& Returns  : Array of strings
\& Args     : [optional] \*(Aqbreadth\*(Aq/\*(Aqdepth\*(Aq \- indicates the order for returning
\&            keys
\& Status   : Virtual
.Ve
.Sh "\fIget_Annotations()\fP"
.IX Subsection "get_Annotations()"
.Vb 6
\& Title    : get_Annotations
\& Usage    : my @annotations = $collection\->get_Annotations(\*(Aqkey\*(Aq)
\& Function : Retrieves all the Biome::Role::Annotate objects for a specific key
\& Returns  : list of instances that Annotate \- empty if no objects stored for a key
\& Args     : string which is key for annotations
\& Status   : Virtual
.Ve
.Sh "get_nested_Annotations"
.IX Subsection "get_nested_Annotations"
.Vb 8
\& Title    : get_nested_Annotations
\& Usage    : my @annotations = $collection\->get_nested_Annotations(
\&                                \*(Aq\-key\*(Aq => \e@keys,
\&                                \*(Aq\-recursive => 1);
\& Function : Retrieves all the Biome::Role::Annotate objects for one or more
\&            specific key(s). If \-recursive is set to true, traverses the nested 
\&            annotation collections recursively and returns all annotations 
\&            matching the key(s).
\&
\&            If no key is given, returns all annotation objects.
\&
\&            The returned objects will have their tagname() attribute set to
\&            the key under which they were attached, unless the tagname was
\&            already set.
\& Returns  : list of Biome::Role::Annotate \- empty if no objects stored for a key
\& Args     : \-keys      => arrayref of keys to search for (optional)
\&            \-recursive => boolean, whether or not to recursively traverse the 
\&             nested annotations and return annotations with matching keys.
\& Status   : Virtual
.Ve
.Sh "get_all_Annotations"
.IX Subsection "get_all_Annotations"
.Vb 5
\& Title    : get_all_Annotations
\& Usage    : 
\& Function : Similar to get_Annotations, but traverses and flattens nested
\&            annotation collections. This means that collections in the
\&            tree will be replaced by their components.
\&
\&            Keys will not be passed on to nested collections. I.e., if the
\&            tag name of a nested collection matches the key, it will be
\&            flattened in its entirety. 
\&
\&            Hence, for un\-nested annotation collections this will be identical
\&            to get_Annotations.
\& Example  :
\& Returns  : an array of L<Biome::Role::Annotate> compliant objects
\& Args     : keys (list of strings) for annotations (optional)
\& Status   : Virtual
.Ve
.Sh "get_num_of_Annotations"
.IX Subsection "get_num_of_Annotations"
.Vb 6
\& Title    : get_num_of_Annotations
\& Usage    : my $count = $collection\->get_num_of_Annotations()
\& Function : Returns the count of all annotations stored in this collection 
\& Returns  : integer
\& Args     : none
\& Status   : Virtual
.Ve
.Sh "Iterator-based methods"
.IX Subsection "Iterator-based methods"
.Sh "next_Annotation"
.IX Subsection "next_Annotation"
.Vb 10
\& Title   :  next_Annotation
\& Usage   :  my @annotations = $collection\->next_Annotation(\-keys => [\*(Aqfoo\*(Aq, \*(Aqba
\&             \-recursive => 1);
\& Function:  Iterates through the contained Annotations
\& Returns :  list of Biome::Role::Annotate \- empty if no objects stored for a key
\& Args    :  \-keys      => arrayref of keys to search for (optional)
\&            \-type      => arrayref of types to search for (optional)
\&            \-recursive => boolean, whether or not to recursively traverse the 
\&             nested annotations and return annotations with matching keys.
\& Status   : Virtual
.Ve
.Sh "next_Collection"
.IX Subsection "next_Collection"
.Vb 9
\& Title    : next_Collection
\& Usage    : my @annotations = $collection\->next_Collection(\-keys => [\*(Aqfoo\*(Aq, \*(Aqba
\&             \-recursive => 1);
\& Function : Iterates through the contained Annotations
\& Returns  : list of Biome::Role::Annotate \- empty if no objects stored for a key
\& Args     : \-keys      => arrayref of keys to search for (optional)
\&            \-recursive => boolean, whether or not to recursively traverse the 
\&             nested annotations and return annotations with matching keys.
\& Status   : Virtual
.Ve
.Sh "Adding/removing annotation"
.IX Subsection "Adding/removing annotation"
.Sh "add_Annotations"
.IX Subsection "add_Annotations"
.Vb 6
\& Usage    : $self\->add_Annotations(\-tagname => \*(Aqreference\*(Aq,
\&                                   \-$object);
\&            $self\->add_Annotations($object,\*(AqBio::MyInterface::DiseaseI\*(Aq);
\&            $self\->add_Annotations($object);
\&            $self\->add_Annotations(\*(Aqdisease\*(Aq,$object,\*(AqBio::MyInterface::DiseaseI\*(Aq);
\& Function : Adds an annotation for a specific key.
\&
\&            If the key is omitted, the object to be added must provide a value
\&            via its tagname(). 
\&
\&            If the archetype is provided, this and future objects added under
\&            that tag have to comply with the archetype and will be rejected
\&            otherwise.
\&
\& Returns :  none
\& Args    :  annotation key (\*(Aqdisease\*(Aq, \*(Aqdblink\*(Aq, ...)
\&            object to store (must implement Biome::Role::Annotate Role)
\&            [optional] object archetype to map future storage of object
\&            of these types to
\& Status   : Virtual
.Ve
.Sh "\fIremove_Annotations()\fP"
.IX Subsection "remove_Annotations()"
.Vb 8
\& Usage    :
\& Function : Remove the annotations for the specified key from this collection.
\& Returns  : an list of Biome::Role::Annotate compliant objects which were stored
\&            under the given key(s)
\& Args     : the key(s) (tag name(s), one or more strings) for which to
\&            remove annotations (optional; if none given, flushes all
\&            annotations)
\& Status   : Virtual, but unstable (needs to be defined more specifically)
.Ve
.Sh "flatten_Annotations"
.IX Subsection "flatten_Annotations"
.Vb 3
\& Title   : flatten_Annotations
\& Usage   :
\& Function: Flattens part or all of the annotations in this collection.
\&
\&           This is a convenience method for getting the flattened
\&           annotation for the given keys, removing the annotation for
\&           those keys, and adding back the flattened array.
\&
\&           This should not change anything for un\-nested collections.
\& Example :
\& Returns : an array Biome::Role::Annotate compliant objects which were stored
\&           under the given key(s)
\& Args    : list of keys (strings) the annotation for which to flatten,
\&           defaults to all keys if not given
\& Status   : Virtual
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
None.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
None.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
None.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
There are no known bugs in this module.
Please report problems to Chris Fields (cjfields at bioperl dot org)
Patches are welcome.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Abstract interface role; in general, any consumers should follow the \s-1SYNOPSIS\s0
for general ideas
.SH "FREQUENTLY ASKED QUESTIONS"
.IX Header "FREQUENTLY ASKED QUESTIONS"
\&...
.SH "COMMON USAGE MISTAKES"
.IX Header "COMMON USAGE MISTAKES"
\&...
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Biome::Role::Annotate
Biome::Role::ManageTypes
.PP
The original BioPerl interface/implementation (Bio::AnnotationCollectionI and
Bio::Annotation::Collection)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Ewan Birney (original BioPerl implementation)
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Fields  (cjfields at bioperl dot org)
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2009 Chris Fields (cjfields at bioperl dot org). All rights reserved.
.PP
followed by whatever licence you wish to release it under.
For Perl code that is often just:
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
