From 05e33e82c51957880388beb4ae67a2335432b030 Mon Sep 17 00:00:00 2001
From: Siddhartha Basu <biosidd@gmail.com>
Date: Fri, 25 Sep 2009 07:09:58 -0500
Subject: Decided not to inherit from Atomic for each location implementation,  rather switch them
 to using the BioMe::Role::Location
 Still reorganizing to decide how many methods will remain 'required' in Location role
 implementation.

---
 lib/Biome/Location/Atomic.pm |   52 +++---------------
 lib/Biome/Location/Simple.pm |  124 ++++++++++++++++++++++--------------------
 2 files changed, 74 insertions(+), 102 deletions(-)

diff --git a/lib/Biome/Location/Atomic.pm b/lib/Biome/Location/Atomic.pm
index 455441fac3bf1147106522bf14b294dce554fddf..1fb153a509e4e93c958341b575c0f71dbe432fa6 100644
--- a/lib/Biome/Location/Atomic.pm
+++ b/lib/Biome/Location/Atomic.pm
@@ -5,7 +5,7 @@
 package Biome::Location::Atomic;
 use Biome;
 use Biome::Location::WidestCoordPolicy;
-use Biome::Types qw/SequenceStrand Int Str CoordinatePolicy/;
+use Biome::Types qw/Int Str CoordinatePolicy/;
 
 with 'Biome::Role::Location';
 
@@ -25,12 +25,7 @@ with 'Biome::Role::Location';
 
 =cut
 
-has [qw/start end/] => ( 
-	is => 'rw', 
-	isa => 'Int', 
-);
-
-after 'start' => sub {
+sub _build_start {
   my ($self,  $value ) = @_;	
   $self->min_start($value) ;
 }
@@ -46,7 +41,7 @@ after 'start' => sub {
 
 =cut
 
-after 'end' => sub {
+sub _build_end {
   my ($self,  $value ) = @_;	
   $self->min_end($value) ;
 }
@@ -62,10 +57,6 @@ after 'end' => sub {
 
 =cut
 
-has 'strand' => ( 
-	is => 'rw', 
-	isa => SequenceStrand, 
-);
 
 =head2 seq_id
 
@@ -198,27 +189,6 @@ has [qw /start_pos_type end_pos_type location_type/]  => (
 );
 
 
-=head2 is_remote
-
- Title   : is_remote
- Usage   : $self->is_remote($newval)
- Function: Getset for is_remote value
- Returns : value of is_remote
- Args    : newvalue (optional)
-
-
-=cut
-
-sub is_remote {
-   my $self = shift;
-   if( @_ ) {
-       my $value = shift;
-       $self->{'is_remote'} = $value;
-   }
-   return $self->{'is_remote'};
-
-}
-
 =head2 each_Location
 
  Title   : each_Location
@@ -233,7 +203,7 @@ sub is_remote {
 
 =cut
 
-sub each_Location {
+sub _build_each_Location {
    my ($self) = @_;
    return ($self);
 }
@@ -248,9 +218,7 @@ sub each_Location {
 
 =cut
 
-has 'to_FTstring'  => (
-	is => 'ro', 
-	default => sub { 
+sub _build_FTstring {  
     	my($self) = @_;
     	if( $self->start == $self->end ) {
 			return $self->start;
@@ -260,8 +228,7 @@ has 'to_FTstring'  => (
 			$str = sprintf("complement(%s)", $str);
     	}
     	return $str;
-	}
-);
+}
 
 =head2 valid_Location
 
@@ -274,14 +241,11 @@ has 'to_FTstring'  => (
 
 =cut
 
-has 'valid_Location' => (
-	is => 'ro', 
-	default => sub { 
+sub _build_valid_Location { 
 		my ($self) = @_;
     	return 1 if $self->start && $self->end;
     	return 0;
-	},
-);
+}
 
 =head2 coordinate_policy
 
diff --git a/lib/Biome/Location/Simple.pm b/lib/Biome/Location/Simple.pm
index 858743c32be6160128f21a1f24788f3b30ebf5ff..9bc8d1067a47e3aebed384c2fb77af964db2b478 100644
--- a/lib/Biome/Location/Simple.pm
+++ b/lib/Biome/Location/Simple.pm
@@ -2,45 +2,14 @@
 
 package BioMe::Location::Simple;
 use MooseX::AttributeHelpers;
-extends 'BioMe::Location::Atomic';
+use Biome;
+use Biome::Location::WidestCoordPolicy;
+use Biome::Types qw/SequenceStrand Int Str CoordinatePolicy/;
 
-has 'rangeencode' = ( 
-	metaclass => 'Collection::Hash', 
-	is => 'rw', 
-	isa => 'HashRef[Str], 
-	lazy => 1, 
-	builder => '_build_range_encoding', 
-	provides => { 
-		exists => 'has_encoding', 
-		keys => 'encoding_types', 
-		get => 'decode', 
-		set => 'encode'
-	}
-);
-
-sub _build_range_encoding { 
-	my ($self) = @_;
-
-my %range_encode = (
-    '\.\.' => 'EXACT',
-    '\^'   => 'IN-BETWEEN', 
-    'EXACT'      => '..',
-    'IN-BETWEEN' => '^'
-);
-
-$self->encode(%range_encode);
-}
-
-sub new {
-    my ( $class, @args ) = @_;
-    my $self = $class->SUPER::new(@args);
+with 'Biome::Role::Location';
 
-    my ($locationtype) = $self->_rearrange( [qw(LOCATION_TYPE)], @args );
 
-    $locationtype && $self->location_type($locationtype);
 
-    return $self;
-}
 
 =head2 start
 
@@ -53,21 +22,18 @@ sub new {
 
 =cut
 
-sub start {
-    my ( $self, $value ) = @_;
-    $self->{'_start'} = $value if defined $value;
-
+sub _build_start {
+    my ( $self ) = @_;
     $self->throw( "Only adjacent residues when location type "
           . "is IN-BETWEEN. Not ["
-          . $self->{'_start'}
+          . $self->start
           . "] and ["
-          . $self->{'_end'}
+          . $self->end
           . "]" )
-      if defined $self->{'_start'}
-      && defined $self->{'_end'}
+      if $self->has_start
+      && $self->has_end
       && $self->location_type eq 'IN-BETWEEN'
-      && ( $self->{'_end'} - 1 != $self->{'_start'} );
-    return $self->{'_start'};
+      && ( $self->end - 1 != $self->start );
 }
 
 =head2 end
@@ -85,34 +51,33 @@ sub start {
 
 =cut
 
-sub end {
-    my ( $self, $value ) = @_;
-
-    $self->{'_end'} = $value if defined $value;
 
+sub _build_end {
+    my ( $self ) = @_;
     #assume end is the same as start if not defined
-    if ( !defined $self->{'_end'} ) {
-        if ( !defined $self->{'_start'} ) {
+    if ( !$self->has_end ) {
+        if ( !$self->has_tart ) {
             $self->warn('Calling end without a defined start position');
             return;
         }
         $self->warn('Setting start equal to end');
-        $self->{'_end'} = $self->{'_start'};
+        $self->end($self->start);
     }
+
     $self->throw( "Only adjacent residues when location type "
           . "is IN-BETWEEN. Not ["
-          . $self->{'_start'}
+          . $self->start
           . "] and ["
-          . $self->{'_end'}
+          . $self->end
           . "]" )
-      if defined $self->{'_start'}
-      && defined $self->{'_end'}
+      if $self->has_start
+      && $self->has_end
       && $self->location_type eq 'IN-BETWEEN'
-      && ( $self->{'_end'} - 1 != $self->{'_start'} );
+      && ( $self->end - 1 != $self->start );
 
-    return $self->{'_end'};
 }
 
+
 =head2 strand
 
   Title   : strand
@@ -124,6 +89,8 @@ sub end {
 
 =cut
 
+
+
 =head2 length
 
  Title   : length
@@ -347,6 +314,47 @@ sub trunc {
     return $out;
 }
 
+has 'rangeencode' = ( 
+	metaclass => 'Collection::Hash', 
+	is => 'rw', 
+	isa => 'HashRef[Str], 
+	lazy => 1, 
+	builder => '_build_range_encoding', 
+	provides => { 
+		exists => 'has_encoding', 
+		keys => 'encoding_types', 
+		get => 'decode', 
+		set => 'encode'
+	}
+);
+
+=head2 _build_range_encoding
+
+  Title   : _build_range_encoding
+  Usage   : 
+  Function: 
+  Returns : 
+  Args    : 
+
+=cut
+
+
+
+sub _build_range_encoding { 
+	my ($self) = @_;
+
+my %range_encode = (
+    '\.\.' => 'EXACT',
+    '\^'   => 'IN-BETWEEN', 
+    'EXACT'      => '..',
+    'IN-BETWEEN' => '^'
+);
+
+$self->encode(%range_encode);
+}
+
+
+
 
 no BioMe;
 
-- 
1.5.3.7


